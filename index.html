<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Type-driven contract development</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <style type="text/css">
    code {
      color: #a8c;
    }
    section.jack h2, section.jack h3 {
      color: #f33;
    }
    section.robert h2, section.robert h3 {
      color: #a3f;
    }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>kell Compilation Sy

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section style="text-align: left;">
          <h3>Safer smart contracts through type-driven development</h3>
          <p>
          <div style="line-height:70%;">
          <small>Jack Pettersson and Robert Edström</small><br>
            <small>MSc thesis at Chalmers University of Technology</small>
          </div>
          </p>
          
        </section>

        <section style="text-align: left;">
          <h2>Agenda</h2>
          <p>
            <ol>
              <li>Contracts</li>
              <li>Smart contracts</li>
              <li>Ethereum</li>
              <li>Common errors</li>
              <li>Our solutions</li>
              <li>The Idris programming language</li>
              <li>Our implementation</li>
              <li>Demo</li>
              <li>Summary</li>
              <li>Questions</li>
            </ol>
          </p>
          
        </section>
        <section class="jack">
          <h2>Contracts</h2>
          <ul>
            <li>Written agreements</li>
            <li>Essentially formal</li>
            <li>Possible to automate?</li>
          </ul>
          <aside class="notes">
          <p>Ok, so let's begin by talking a little bit about contracts. Contracts are very central to our modern society. But what are they?
          Essentially, they are written agreements.</p>
          <p>For example, "if <i>you</i> don't pay your rent, then <i>I</i> have the right to kick you out of your apartment"</p>
          <p>Of course, most contracts are much more complicated than that, but at their core, they are more or less logical formulae.<br/>
          For example: "<i>if</i> x happens, y holds" or "<i>at</i> time t, perform z"</p>
          <p>As we know, computers are very good at logic, so it's natural to ask:<br/>
          <i>can</i> we describe contracts using code and execute them?</p>
          <p>The answer is: Yes, we can!</p>
          <p>Computer scientists have known this for a long time. There actually exist many formal languages and libraries that are specialized on specifying, executing and analyzing contracts.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>

        <section data-transition="slide-in fade-out" class="jack">
          <h2>Example contract:<br>European option</h2>
          <p>"At time <code>t</code>, party <code>a</code> may buy asset <code>x</code> from party <code>b</code> for price <code>y</code>"</p>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
function buy() {
  if(currentTime == t) {
    a.give(b,y)
    b.give(a,x)
  }
}
          </code></pre>
          <p class="fragment">Who executes this?</p>
          <aside class="notes">
          <p>Ok, so let's say that we wanted to turn all the contracts in the world into code. Just to give you an intuition of how that might look, let's take a very common financial contract and try to encode it as a program.</p>
          <p>We'll take a so-called European Option. They allow the holder to buy an asset at a fixed price, but only at a particular time. Or: "at time t, party a may buy asset x from party b for price y"<br />
          <strong><i>CLICK</i></strong><br />
          <p>Here is some object-oriented pseudocode that encodes these rules. If the holder wants to buy the asset, they simply call the buy function. The function checks the current time and transfers the money and the asset.</p>
          <p>This is all very well, but there is one major question: <strong><i>CLICK</i></strong><br/>
          Who <i>executes</i> this code? On <i>whose</i> computer is it running? Can both parties <i>trust</i> the executor?</p>
          <p><i>If</i> we should start to codify contracts at a large scale, it is extremely important that they can't be modified by anyone and that anyone can verify that they are executed correctly.</p>
          <p>The perfect scenario would be if the code could "execute itself", without any possibility of interference.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>
        
        <section class="jack">
          <h2>Smart contracts</h2>
          <ul>
            <li>Self-enforcing contracts</li>
            <li>Primitive example: vending machines</li>
            <li class="fragment" data-fragment-index="1">Now: smart contract platforms</li>
            <li class="fragment" data-fragment-index="1">Applications: finance, IoT, commerce, computer protocols, gambling, ...</li>
          </ul>
          <aside class="notes">
          <p>...And that's <i>exactly</i> what smart contracts are about!</p>
          <p>A primitive precursor to smart contracts can be found in a simple vending machine:<br />
            "<i>If</i> you deposit a coin, you <i>will</i> receive a soda"<br/>
            Of course, vending machines <i>are</i> possible to interfere with, but it isn't very easy and as I said, it's just a primitive precursor.<br />
          <strong><i>CLICK</i></strong><br />
          <p>But as it turns out, the last few years, <i>programmable</i> smart contract <i>platforms</i> have become a thing. They offer developers a programming language to specify <i>arbitrary</i> smart contracts in, and then the <i>platform</i> ensures that they are executed <i>exactly</i> as specified.</p>
          <p>This is <i>extremely</i> powerful. It can be used in <i>a lot</i> of fields, and not just finance.</p>
          <p>Just as an example, IBM has experimented with using a smart contract platform as the backbone for the internet of things. And based on what <i>they</i> say, it seems very promising. What they are doing is basically to allow devices to <i>negotiate</i> with each other and decide on their behavior in a kind of <i>device democracy</i>, without relying on any servers.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>
        
        
        
        <section class="robert">
          <h2>Ethereum</h2>
          <h3>A smart contract platform</h3>
          <ul>
            <li><strong><i>Peer-to-peer</i></strong> network executing...</li>
            <li><strong><i>Arbitrary</i></strong> rules, leading to a...</li>
            <li><strong><i>Globally</i></strong> accepted state</li>
          </ul>
          <p class="fragment">Result: the rules enforce themselves</p>
          <aside class="notes">
          <p>Ok, so we have looked at the smart contract platform Ethereum.</p>
          <p>It is a peer-to-peer network. Is anyone here not familiar with P2P networks?</p>
          <p>(Ok, are you familiar with Bittorrent or Bitcoin? Ok, so both of those are decentralized P2P networks. It essentially means that all computers in the network are equal in terms of network control. There is no central server or anything else that coordinates the network. Instead all participants communicate directly with each other. This means that no particular computer is required for the network to operate. It is just enough that there are <i>some</i> computers in the network.)</p>
          <p>Ok, so the participants in this P2P network execute arbitrary rules. These rules are the contracts on the platform and can be specified by anyone.</p>
          <p>After executing a contract, the participants verify that they all got the same result. This result is published for the world to see.</p>
          <p>This means that a network which no one controls is able to say "<strong>this</strong> is the result of executing this contract", and if anyone disagrees, it is easy to prove them wrong<br />
          <strong><i>CLICK</i></strong><br />
          <p>So just like we wished for, the contracts essentially execute themselves, without any need to trust the executor.</p>
          </aside>
        </section>
<!--
        <section>
          <h2>Ethereum</h2>
          <h3>Globally accepted state</h3>
          <ul>
            <li>Reached through consensus algorithm</li>
            <li class="fragment">Blockchain - generalization of the Bitcoin ledger</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
      -->
        <section class="robert">
          <h3>Ethereum smart contract languages</h3>
          <p>Contracts = byte code on the Ethereum Virtual Machine</p>
          <ul>
            <li class="fragment">Solidity ≈ JavaScript</li>
            <li class="fragment">Serpent ≈ Python</li>
            <li class="fragment">LLL ≈ LISP</li>
          </ul>
          <aside class="notes">
            <p>All contracts on Ethereum run on a virtual machine, called the EVM. The EVM is Turing complete, so any business logic can be encoded as a smart contract. Anyone can upload contracts and anyone can call any uploaded contract.</p>
<p></p>
            <p>Contracts are stored in a custom binary format, so if you want to write Ethereum smart contracts you will have to use a language that compiles down to this. There currently exist three such languages:<br />
          <strong><i>CLICK</i></strong><br />
            <p>* Solidity, which is the most mainstream and mature one. The syntax is very similar to JavaScript.<br />
          <strong><i>CLICK</i></strong><br />
            <p>* Serpent, which looks like Python<br />
          <strong><i>CLICK</i></strong><br />
            <p>* And LLL, which stands for Low-Level LISP.</p>
<p></p>
            <p>So with that out of the way, let's look at how a simple contract can look in Solidity.</p>
          </aside>
        </section>
        <section class="jack" data-transition="slide-in fade-out">
          <h2>Example contract</h2>
          <h3>Name registry</h3>
          <p>Written in Solidity</p>
          <pre><code class="hljs" data-trim contenteditable>
contract KeyValueStore {
  mapping (int => int) store;
  
  function register(int key, int value) returns boolean {
    if(msg.sender == 598707698970987908 && msg.value >= 10) {
      store[key] = value;
      return true;
    }
    return false;
  }
  
  function get(int key) returns int {
    return store[key];
  }
}
          </code></pre>
          <p class="fragment">Everyone executes this!</p>
          <aside class="notes">
            <p>This is a simple key value store</p>
            <p>All contracts have a persistent data storage that they can use to store arbitrary data. In this case, we declare a mapping from keys to values. Both the keys and values are simple integers.</p>
            <p>We only want a single person to be allowed to register values, which we check here by comparing the sender to a hard-coded address.<br/>
              Also, to register a value has a price. Here we say that the price is 10.<br/>
              And anyone can get values.<br />
          <strong><i>CLICK</i></strong><br />
            <p>Remember that in Ethereum, we don't need to trust the executor: We can say that EVERYONE executes this. So this is effectively like a kind of DNS that no one controls. ...Even though the rules are a bit strange for a DNS...</p>
            <p>We could change the rules though. We could allow anyone to register, but only allow changes by the creator of each key. We could also add rules like expiry time, renewal costs, and so on.</p>
<p></p>
            <p>But anyway, I mentioned prices and costs, so let's take a quick look at how that is modeled in Ethereum.</p>
          </aside>
        </section>
        <section class="jack">
          <h2>Ether</h2>
          <ul>
            <li>Currency/token</li>
            <li class="fragment" data-fragment-index="1">May be sent separately</li>
            <li class="fragment" data-fragment-index="1">May be sent as part of function call</li>
          </ul>
          <aside class="notes">
            <p>In short, ethereum has an internal token called ether which can be used to transfer real value. Each user and contract on Ethereum have a specific balance of Ether. Both users and contracts can send any ether they own to any other contract or user.<br />
          <strong><i>CLICK</i></strong><br />
          <p>Ether can also be included when calling a contract function, so contracts can behave differently depending on how much ether that was included.</p>
          <p>Has anyone heard of Bitcoin but not of Ethereum? (Ether is to Ethereum what the currency bitcoin is to the Bitcoin network.)</p>
          </aside>
        </section>
 
        <section class="jack">
          <section data-transition="slide-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
<p>A game of two players. Joining costs exactly 10 ether.</p>
          <pre class="fragment"><code data-trim contenteditable>

joinGame : Int -> EthereumEff (success : Bool)
joinGame move = do
  pc <- read playerCount
  if pc < 2 && !value >= 10
    then do
      write players pc (!sender,move)
      write playerCount (pc+1)

      return True
    else do

      return False
          </code></pre>
          <p class="fragment">Ether is not handled correctly!</p>
          <aside class="notes">
            <p>Ok, so now that we have explained the area that we're working <i>in</i>, it's time to explain what <i>we've</i> been trying to do.</p>
            <p>To do this, we will start with showing you a <i>slightly</i> more complicated contract. It's a game. You might know it, it's called rock-paper-scissors. Basically, two players send their moves and 10 ether each to a contract, which pays the winner 20 ether.</p>
            <p>Just a question beforehand: is anyone here not familiar with functional programming?<br/>
              (Ok, no worries, there shouldn't be too many strange things going on, but I'll make sure to explain the code properly anyway. You don't have to worry about the small details)<br />
            <strong><i>CLICK</i></strong><br />
            <p>Ok, so this is the function that players call to join the game. For simplicity, we represent the moves as integers, so the function takes an integer and returns true if the player could join the game and false otherwise.</p>
            <p>As you can see though, the return type is not a <i>normal</i> boolean, but it is something called "EthereumEff" which <i>contains</i> a boolean.<br/>
            Basically, this says that the function doesn't <i>only</i> take an integer and return a boolean, it could <i>also</i> use the state of the Ethereum system in some way. Basically, the function doesn't return a boolean, but it returns <i>instructions</i> on how to <i>use</i> Ethereum to <i>create</i> a boolean.</p>
            <p>In this case for example, it has to check how many players are already in the game. To do this, it has to <i>read</i> a value from the <i>state</i>, which is why the function returns an EthereumEff. The value that is read is saved in 'pc'.</p>
            <p>Then we use 'pc' to check that the game is not full. We <i>also</i> have to check that the player sent enough ether. The amount of ether that was included in the call is accessed using the variable 'value', as we can see here.<br/>     

Contracts

    Written agreements
    Essentially formal
    Possible to automate?

Example contract:
European option

"At time t, party a may buy asset x from party b for price y"


            Just like this 'joinGame' function doesn't return a simple boolean, 'value' doesn't return a simple integer. The exclamation mark basically allows us to treat it as if it was a simple integer.</p>
            <p>So if the game is not full <i>and</i> the player payed enough ether, we should just save the player and its move, increase the number of players and then return true. Otherwise we just return false.</p>
            <p>This might <i>seem</i> reasonable, but there are actually a few bugs here.</p>
            <p>For starters, what happens if the game was already full? Then we return false, but we don't return the fee for joining the game!<strong><i>CLICK</i></strong></p>
            <p>The player would lose the ether and not be able to retrieve it. So let's fix this! <strong><i>CLICK</i></strong></p>
          </aside>
          </section>
          <section class="jack" data-transition="fade-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
          <p>Amended version</p>     

Contracts

    Written agreements
    Essentially formal
    Possible to automate?

Example contract:
European option

"At time t, party a may buy asset x from party b for price y"


          <pre><code data-trim contenteditable>
joinGame : Int -> EthereumEff (success : Bool)
joinGame move = do
  pc <- read playerCount
  if pc < 2 && !value >= 10
    then do
      write players pc (!sender,move)
      write playerCount (pc+1)
      send (!value-10) !sender
      return True
    else do
      send !value !sender
      return False
          </code></pre>
          <p class="fragment">The move is revealed!</p>
          <aside class="notes">
            <p>Ok, so now we return the fee.</p>
            <p>And <i>also</i>, if the player <i>was</i> able to join the game, we return any excess ether.</p>
            <p>As you can see, the solution was really easy, but detecting errors like these can be <i>hard</i>, especially in more complex contracts.</p>
            <p>Anyway, this implementation is better, but one bug remains. As you might recall from when Robert explained Ethereum, the state of the system is completely public.<br />
            <strong><i>CLICK</i></strong><br />
            <p>So the <i>second</i> player will be able to see the <i>first</i> player's move <i>before</i> joining the game.</p>
            <p>We won't solve this right now because the solution is a bit complicated, but keep it in mind for later.<br />
            <strong><i>CLICK</i></strong><br />
          </aside>
          </section>
        </section>

        <section class="jack">
          <h2>Common errors</h2>
          <table>
            <thead>
              <tr>
                <th>Mistake</th>
                <th class="fragment" data-fragment-index="1">Solution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Wrong handling of ether</td>
                <td class="fragment" data-fragment-index="1">Encode ether flow in the type system</td>
              </tr>
              <tr>
                <td>Openly communicating secret information</td>
                <td class="fragment" data-fragment-index="1">Include crypto schemes in library and compiler</td>
              </tr>
              <!--
              <tr>
                <td>Incentive incompatibility</td>
                <td>?</td>
              </tr> -->
            </tbody>
          </table>
          <aside class="notes">
            <p>Ok, so we have showed you two classes of errors that are common for smart contract developers to make.</p>
            <p>The first was to not handle ether properly, and the second was to upload secret information.</p>
            <p><i>Our thesis</i> is that these problems can be solved at the language level with an extensive type system.<br />
            <strong><i>CLICK</i></strong><br />
            <p>In particular, we will show you <i>how</i> the type system can encode ether flow.<br/>
            We will <i>also</i> show you why type annotations is a natural way to use cryptographic schemes that are built into the compiler.</p>
            <p>(Explain type annotations)<br />
            <strong><i>CLICK</i></strong><br />
          </aside>
        </section>
        <section class="jack">
          <h2>Motivations</h2>
          <ul>
            <li>Catch bugs using type system</li>
            <li class="fragment">Functional paradigm</li>
          </ul>
          <aside class="notes">
            <p>Ok, so our main motivation for doing this is to catch bugs at compile time instead of run time.</p>
            <p>To do this, we will use the type system in <i>two</i> ways. The <i>first</i> is to use types to enforce how contracts are allowed to behave. The <i>second</i> is to use types to tell the compiler which values that are secret.<br />
            <strong><i>CLICK</i></strong><br />
            <p>And as you've seen in our examples so far, we also use a functional language.<br/>
            As you may remember, we mentioned in the beginning that there already exist a lot of formal languages and libraries that are <i>specialized</i> on contracts.<br/>
            Many of <i>those</i> are in fact functional, so that's why <i>our</i> language is functional.</p>
            <p>But just to be clear, our goal was <i>not</i> to design a new language or library specialized on contracts.<br/>
            We wanted to do a <i>general-purpose</i> programming language on a <i>smart contract</i> platform. <i>However</i>, our language <i>should</i> make it possible to <i>implement</i> those libraries in an environment where you <i>don't</i> have to trust an executor.</p>
          </aside>
        </section>
        <section>
          <section data-transition="slide-in fade-out" data-center="false" class="robert">
            <h2>Catch errors using types</h2>
            <p>
            &nbsp;
            </p>
            <pre><code>
joinGame : Int ->
           EthereumEff (success : Bool)
              
 
 
 
             
            </pre></code>
          <aside class="notes">
            So let's look at an example of how our solution works in practice. We'll modify the type of the joinGame function from rock paper scissors that we saw earlier. We want to keep the same functionality, but include the properties we want to enforce in the type signature. 
          </aside>
          </section>
          <section data-transition="fade-in fade-out" data-center="false" class="robert">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
joinGame : Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = trans
           ; KEEP    = keep
           }
            </pre></code>
            <ul>
            <li>Function is undefined for value < 10</li>
            </ul>
          <aside class="notes">
            <p>The Ethereum effect has some optional parameters. In this example, we include:<br />
            the amount of ether included for this call,<br />
            the ether balance of the contract, <br />
            the amount of outgoing ether transferred to others during the call,<br />
            and the amount of incoming ether that's kept in the contract after the call.</p>
            <p>As Jack mentioned, we want to make sure that the player can only join the game if they pay the fee of 10 ether. As you can see here, we take an additional parameter p. P is a proof that value is at least 10. LTE stands for less-than-or-equal and these curly brackets mean that p is implicit and should be inferred when possible.</p>
            <p>You can also see that we are actually including the VALUE of the parameter value in the type signature, not just its type. In case you're familiar with dependent types, we can do this because our language supports them.</p>
            <p>Now, the type system has made sure that only calls with at least 10 ether will execute this function. Let's see how we can also enforce that the proper amount of ether is kept and transferred.</p>
          </aside>
          </section>
          <section data-transition="fade-in fade-out" data-center="false" class="robert">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
joinGame : Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
            </pre></code>
            <ul>
            <li class="fragment">Transferred and kept ether defined for all paths</li>
            <li class="fragment">First implementation wouldn't type check</li>
            </ul>
          <aside class="notes">
            <p>OK, so if the player joined the game, the contract should keep 10 ether and if they didn't, it should keep nothing. This is defined here. </p>
            <p>We also specify that if the player joined, they should get back any amount of ether exceeding 10 and if they didn't, everything they sent should be returned. You can see that here.<br/>
            <strong><i>CLICK</i></strong><br />
            Again, we are allowed to type check the returned value of the function and even include the result of an expression in the type signature. Keep in mind that this check happens at compile time rather than run time.<br />
            <p><strong><i>CLICK</i></strong></p>
            <p>If we used this type for the first version of the implementation, it wouldn't compile, while the fixed version would.</p>
          </aside>
          </section>
          <section data-transition="fade-in slide-out" class="robert">
            <h2>Catch errors using types</h2>
            <p>
              Hide player move
            </p>
            <pre><code>
joinGame : Commit Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
            </pre></code>
            <ul>
            <li>Commitments part of the language</li>
            <li class="fragment">Revealing function is generated at compile-time:<pre><code>
reveal : Int -> Int -> a -> EthereumEff (success : Bool) {}
</code></pre></li>
            <li class="fragment">Accessed using a library function:<pre><code>
open : Commit a -> EthereumEff (value : Maybe a) {}
            </code></pre></li>
            <li class="fragment">Not implemented</li>
            </ul>
          <aside class="notes">
            <p>Now for the last problem that Jack mentioned; how to hide the player's move from being publicly read. This is done using a cryptographic construction called a commitment - basically, it means that a player can commit to a specific value without that value being known until they choose to reveal it. If we use the type Commit here, we signify to the compiler that it should generate the necessary code for this. <br />
            <strong><i>CLICK</i></strong><br />
            <p>The library supplies two functions - the first takes in the necessary parameters to reveal the value that the player commited to. After this is run, the value can be used in the contract.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The second function, open, returns the commited value if it has been revealed.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Unfortunately, this is not yet part of our implementation, so this last part is not usable in practice yet. But it should not be too hairy to add.</p>
          </aside>
          </section>
        </section>
        <section>
          <h2>Type-correct implementation</h2>
          <pre><code class="Haskell" style="max-height: 500px;">
joinGame : Commit Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
joinGame {value} move = do
  pc <- playerCount
  if pc < 2
    then do write players pc (!sender,move)
            write playerCount (pc+1)
            keep 10
            send (value-10) !sender
            pureM True
    else do send value !sender
            pureM False   
          </pre></code>
          
          <aside class="notes">
            So here is the complete joinGame function. The implementation is exactly the same as we saw before, with one small change. pureM is exactly the same as return, but allows us to have differing output effects depending on the return value. Obviously, we would also need code for resolving the winner and so on, but hopefully this is enough to give you an idea of what's going on.
          </aside>
        </section>
        <section class="robert">
          <h2>Implementation</h2>
          <h3>Language: Idris</h3>
          <ul>
            <li class="fragment">Very similar to Haskell, but...</li>
            <li class="fragment">Dependent types</li>
            <li class="fragment">Algebraic effects for environment interaction</li>
            <li class="fragment">Strictly evaluated</li>
            <li class="fragment">Pluggable backends</li>
          </ul>
          <aside class="notes">
            <p>So, now that you've seen how our solution works, let's get down to how we've implemented it. We chose to use an already existing language called Idris. Has anyone heard of it before?<br />
            <strong><i>CLICK</i></strong><br />
            <p>For those of you who haven't, maybe you think the code we showed looked like Haskell. Idris is heavily inspired by Haskell, and the syntax is very similar. I'll just run through the main reasons why we think that Idris is a better fit for Ethereum than Haskell.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The big thing is dependent types. This is what allowed us to be so expressive in the type signatures.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Side effects are icky in any purely functional language. Idris models this using something called algebraic effects, and they are part of the core library. This allowed us to express interaction with the environment in a natural way.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Executing code on Ethereum is actually pretty expensive. So we want something with minimal runtime overhead. Haskell uses lazy evaluation, which is pretty expensive. Idris uses strict evaluation by default, so we didn't have to hack around laziness in our code generator.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Finally, Idris is designed to be easily extended to target new platforms. We looked quite a bit at GHC, the main Haskell compiler, and it is not very well documented how to do this with Haskell. </p>
            <p>So without further ado, let's look at what we've actually done.</p>
          </aside>
        </section>
        <section class="robert">
          <h2>Implementation</h2>
          <h3>Library: Effects</h3>
          <ul>
            <li class="fragment">ETH: Handle ether flow</li>
            <li class="fragment">ENV: Depend on the environment</li>
            <li class="fragment">STORE: Read from and save to data store</li>
          </ul>
          <h3 style="margin-top: 1.5em">Code generator</h3>
          <ul>
            <li class="fragment">Plugs into Idris compiler API</li>
            <li class="fragment">Outputs Serpent</li>
            <li class="fragment">Only works for very simple contracts ATM</li>
          </ul>
          <aside class="notes">
            <p>Our implementation consists of two main parts: A library of effects and a code generator. We have made three effects that can be used independently. They supply both the type checking and allows contract functions to use effectful operations in the implementation.
            <br /><strong><i>CLICK</i></strong><br />
            The first effect is the one we used to handle the flow of ether in the joinGame function.<br />
            <strong><i>CLICK</i></strong><br />
            <p>ENV allows us to get things from the environment. Stuff like the addresses of the sender and the contract, or the current time.<br />
            <strong><i>CLICK</i></strong><br />
            <p>STORE allows us to interact with the contract's data store.</p>
            <p>The EthereumEff we saw before is just syntactic sugar which includes all three.</p>
            <p>That about the library. Let's talk about the code generator.<br />
            <strong><i>CLICK</i></strong><br />
            <p>As I said, we use the Idris compiler API as a library to get an intermidiate abstract syntax tree representation of the contract as input.<br />
            <strong><i>CLICK</i></strong><br />
            <p>We actually don't output Ethereum byte code directly, but instead we output Serpent code. Serpent is the Python-like smart contract language. The Serpent compiler can then be used for the final step.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The current version of the code generator is not complete. All the type checking works as intended, but it only generates working code for a subset of contracts. Let's look at how this is used in practice and see if it works.</p>
          </aside>
        </section>

        <section class="robert">
          <h2>Demo time!</h2>
          <aside class="notes">
            <p>I'll use our code generator to compile a simple contract from Idris to Serpent and then run it on a simulated version of the Ethereum system supplied with Serpent. </p>
<p></p>
            <p>$ vim Namecoin.idr</p>
<p></p>
            <p>This is an Idris implementation of the name registry I showed you before. Just a simple key value store.  We have one storage variable, db, to map integers to integers. As you can see, the "get" function uses the Store effect and returns the value stored for the given key.</p>
<p></p>
            <p>If we look at the "register" function, we can see that we also use the Environment effect. It takes three parameters, and the first two here are implicit and can be anything. But for the third one, the address of the user who initiated the call, we have a fixed value. This means that it will be a type error if anyone else tries to register a value. Let's try to compile and run it.</p>
<p></p>
            <p>$ make namecoin_eio</p>
            <p>$ vim Namecoin.se</p>
<p></p>
            <p>Here is the output from our code generator. This is Serpent. This will be fed to a Python script that does the final stage of compilation and runs a simulator to debug it.</p>
<p></p>
            <p>$ vim runner.py</p>
<p></p>
            <p>The details here are not too important.</p>
            <p>We read in the serpent source.</p>
            <p>Set up the environment.</p>
            <p>We try get and print a value with the key 1337, which has not been set yet.</p>
            <p>We set the value to 42.</p>
            <p>And try to read it again.</p>
<p></p>
            <p>$ ./runner.py</p>
<p></p>
            <p>Looks like it works. Let's see what happens if the origin check would fail by changing the owner address.</p>
<p></p>
            <p>* Change owner address</p>
            <p>$ make namecoin_eio</p>
            <p>$ ./runner.py</p>
<p></p>
            <p>Now it doesn't work anymore.</p>
<p></p>
            <p>So how is this actually enforced? Of course the runtime needs some way to know how to pass the proper arguments to "register" and when it can't and should fail.</p>
<p></p>
            <p>We do this using something we call wrapper functions. They should be possible to automatically generate, but right now you'd have to write them yourself. Let's have a look.</p>
<p></p>
            <p>$ vim Namecoin_EIO</p>
<p></p>
            <p>It's kind of verbose and we'll just glance through this. Let's look at "get". Since there are no types to enforce, we can just pass on the value. If we look at "register", we see that we have to check if the origin is indeed the owner before passing it on to the actual function. This is also where we would pass in any proofs required by the type. Like the one from Rock Paper Scissors where the ether value had to be at least 10.</p>
<p></p>
            <p>Here you see a list of which functions should be accessible from the outside. Maybe a contract has internal functions that should not be callable directly.</p>
          </aside>
        </section>
        <section>
          <h2>Summary</h2>
        <p>An expressive type-system can...
          <ul>
            <li>Catch large classes of errors at compile-time</li>
            <li class="fragment">Generate boiler-plate code</li>
          </ul>
        </p>
        <aside class="notes">
          <p>Let's wrap things up. In summary, we have showed how we can use algebraic effects in combination with dependent types to specify in detail how a program is intended to work and catch bugs at compile time.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Knowing so much about a programs intended behaviour at compile time also allows us to generate a significant amount of boilerplate code.</p>
        </aside>
        </section>
        <section>
        <h2>Work in progress</h2>
         <ul>
          <li>Proof-of-concept implementation</li>
          <li>Lots of future work</li>
         </ul>
          
        <aside class="notes">
          So, we have laid down the theory and design for an implementation of this applying Idris to Ethereum. The implementation itself is still just a proof of concept and especially the code generator will probably have to be rewritten from scratch before it's ready for production use. We hope that someone will pick ball and build upon our work.
        </aside>
        </section>
        <section style="">
          <h1>THANK YOU</h1>
          <h2>Questions?</h2>
              <footer><a href="https://github.com/vindaloo-thesis" target="_blank">https://github.com/vindaloo-thesis</a></footer>
            </ul>
          
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: false,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>

