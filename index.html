<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Type-driven contract development</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <style type="text/css">
    code {
      color: #a8c;
    }
    section.jack h2, section.jack h3 {
      color: #f33;
    }
    section.robert h2, section.robert h3 {
      color: #a3f;
    }
    .reveal .progress {
        top: 0 !important;
        height: 20px !important;
    }
    .reveal .progress span {
        background-color: #a3f !important;
        font-size: 0.5em;
        padding-left: 13px;
        padding-top: 2px;
    }
    </style>
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section style="text-align: left;">
          <h3>Safer smart contracts through type-driven development</h3>
          <p>
          <div style="line-height:70%;">
          <small>Jack Pettersson and Robert Edstr√∂m</small><br>
            <small>MSc thesis at Chalmers University of Technology</small>
          </div>
          </p>
          <aside class="notes">
            <p>Hi! I'm Jack, and this is Robert.</p>
            <p>Today we're gonna talk a little bit about our master's thesis, which is called<br/>
              Safer smart contracts through type-driven development</p>
          </aside>
        </section>

        <section style="text-align: left;">
          <h2>Agenda</h2>
          <p>
            <ol>
              <li>Background</li>
              <li>Conceptual solution</li>
              <li>Implementation</li>
              <li>Demo</li>
              <li>Summary</li>
              <li>Questions</li>
            </ol>
          </p>
          <aside class="notes">
          <p>So, first we'll talk a bit about the background to our work. This includes smart contracts, a smart contract platform called Ethereum and the problems that we've been trying to solve.</p>
          <p>Then, we'll explain how we solve those problems.</p>
          <p>After that we'll talk a little bit about the programming language Idris and how we have implemented our solutions.</p>
          <p>Then we will do a simple demo, before rounding up and finishing with questions!</p>
          </aside>
        </section>
        <section class="jack">
          <h2>Contracts</h2>
          <ul>
            <li>Written agreements</li>
            <li>Essentially formal</li>
            <li>Possible to automate?</li>
          </ul>
          <aside class="notes">
          <p>Ok, so...contracts. They are very important to our society, but what are they, exactly?<br/>
          Well, essentially, they are written agreements.</p>
          <p>For example, "if <i>you</i> don't pay your rent, then <i>I</i> have the right to kick you out of your apartment"</p>
          <p>Of course, most contracts are much more complicated than that, but at their core, they are more or less logical formulae.<br/>
          For example: "<i>if</i> x happens, y holds" or "<i>at</i> time t, perform z"</p>
          <p>As we know, computers are very good at logic, so it's natural to ask:<br/>
          <i>can</i> we describe contracts using code and execute them?</p>
          <p>The answer is: Yes, we can!</p>
          <p>Computer scientists have known this for ages. There actually exist many formal languages and libraries that are specialized on describing contracts, in order to execute or analyze them.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>

        <section data-transition="slide-in fade-out" class="jack">
          <h2>Example contract</h2>
          <p>"At time <code>t</code>, party <code>a</code> may buy asset <code>x</code> from party <code>b</code> for price <code>y</code>"</p>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
function buy() {
  if(currentTime == t) {
    a.give(b,y)
    b.give(a,x)
  }
}
          </code></pre>
          <p class="fragment">Do both parties trust the executor?</p>
          <aside class="notes">
          <p>So let's say that we wanted to turn all the contracts in the world into code. Just to give you an intuition of how that might look, let's take a very common financial contract and try to encode it as a program.</p>
          <p>We'll take a so-called European Option. They allow the holder to buy an asset at a fixed price, but only at a particular time.<br/>
          Or: "at time t, party a may buy asset x from party b for price y"<br />
          <strong><i>CLICK</i></strong><br />
          <p>Here is some object-oriented pseudocode that encodes these rules. If the holder wants to buy the asset, they simply call the buy function. The function checks the current time and transfers the money and the asset.</p>
          <p>This is all very well, but there is one major question: <strong><i>CLICK</i></strong><br/>
          Who <i>executes</i> this code? On <i>whose</i> computer is it running? Can both parties <i>trust</i> the executor?</p>
          <p><i>If</i> we should start to codify contracts at a large scale, it is extremely important that they can't be modified by anyone. And that anyone can verify that they are executed correctly.</p>
          <p>The perfect scenario would be if the code could "execute itself" so to speak, without any possibility of interference.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>
        
        <section class="jack">
          <h2>Smart <span style="font-size:70%">( = self-enforcing)</span> contracts</h2>
          <ul>
            <li>Precursor: vending machines</li>
            <li class="fragment" data-fragment-index="1">State of the art: smart contract platforms</li>
            <li class="fragment" data-fragment-index="1">Applications: finance, IoT, commerce, computer protocols, gambling, ...</li>
          </ul>
          <aside class="notes">
          <p>...And that's <i>exactly</i> what smart contracts are about!</p>
          <p>A primitive precursor to smart contracts can be found in a simple vending machine:<br />
            "<i>If</i> you deposit a coin, you <i>will</i> receive a soda"<br/>
            Of course, vending machines <i>are</i> possible to interfere with, but it isn't very easy and as I said, it's just a primitive precursor.<br />
          <strong><i>CLICK</i></strong><br />
          <p>But as it turns out, the last few years, <i>programmable</i> smart contract <i>platforms</i> have become a thing. They offer developers a programming language to specify <i>arbitrary</i> smart contracts in, and then the <i>platform</i> ensures that they are executed <i>exactly</i> as specified.</p>
          <p>This is <i>extremely</i> powerful. It has applications in <i>several</i> fields, and not just finance.</p>
          <p>Just as an example, IBM has experimented with using a smart contract platform as the backbone for the internet of things. And based on what <i>they</i> say, it seems very promising. What they are doing is basically allowing devices to <i>negotiate</i> with each other and decide on their behavior in a kind of <i>device democracy</i>, without relying on any servers.</p>
          <p>And now Robert will talk a bit about Ethereum, the smart contract platform that both we and IBM have used.</p>
          <strong><i>CLICK</i></strong>
          </aside>
        </section>
        
        
        
        <section class="robert">
          <h2>Ethereum</h2>
          <h3>A smart contract platform</h3>
          <ul>
            <li><strong><i>Peer-to-peer</i></strong> network executing...</li>
            <li><strong><i>Arbitrary</i></strong> rules, leading to a...</li>
            <li><strong><i>Globally</i></strong> accepted state</li>
          </ul>
          <p class="fragment">Result: the rules enforce themselves</p>
          <aside class="notes">
          <p>Ok, so <i>we</i> have been looking at the smart contract platform Ethereum.</p>
          <p>It is a peer-to-peer network. Is anyone here not familiar with P2P networks?</p>
          <p>(Ok, are you familiar with Bittorrent or Bitcoin? Ok, so both of those are decentralized P2P networks. It essentially means that all computers in the network are equal in terms of network control. There is no central server or anything else that coordinates the network. Instead all participants communicate directly with each other. This means that no particular computer is required for the network to operate. It is enough that there are <i>some</i> computers in the network.)</p>
          <p>Ok, so the participants in this particular P2P network execute arbitrary rules. These rules are the contracts on the platform and can be specified by anyone.</p>
          <p>After executing a contract, the participants verify that they all got the same result. This result is published for the world to see.</p>
          <p>This means that a network which no one controls is able to say "<strong>this</strong> is the result of executing this contract", and if anyone disagrees, it is easy to prove them wrong<br />
          <strong><i>CLICK</i></strong><br />
          <p>So just like we wished for, the contracts essentially execute themselves, without any need to trust the executor.</p>
          </aside>
        </section>
<!--
        <section>
          <h2>Ethereum</h2>
          <h3>Globally accepted state</h3>
          <ul>
            <li>Reached through consensus algorithm</li>
            <li class="fragment">Blockchain - generalization of the Bitcoin ledger</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
      -->
        <section class="robert">
          <h3>Ethereum smart contract languages</h3>
          <p>Contracts = byte code on the Ethereum Virtual Machine</p>
          <ul>
            <li class="fragment">Solidity ‚âà JavaScript</li>
            <li class="fragment">Serpent ‚âà Python</li>
            <li class="fragment">LLL ‚âà LISP</li>
          </ul>
          <aside class="notes">
            <p>All contracts on Ethereum run on a virtual machine, called the EVM. The EVM is Turing complete, so any business logic can be encoded as a smart contract. Anyone can upload contracts and anyone can call any uploaded contract.</p>
<p></p>
            <p>Contracts are stored in a custom binary format, so if you want to write Ethereum smart contracts you will have to use a language that compiles down to this. There currently exist three such languages:<br />
          <strong><i>CLICK</i></strong><br />
            <p>* Solidity, which is the most mainstream and mature one. The syntax is very similar to JavaScript.<br />
          <strong><i>CLICK</i></strong><br />
            <p>* Serpent, which looks like Python<br />
          <strong><i>CLICK</i></strong><br />
            <p>* And LLL, which stands for Low-Level LISP.</p>
<p></p>
            <p>So with that out of the way, Jack will show us how a simple contract can look in Solidity.</p>
          </aside>
        </section>
        <section class="jack" data-transition="slide-in fade-out">
          <h2>Example contract: Bank</h2>
          <p>(Written in Solidity)</p>
          <pre><code class="hljs" data-trim contenteditable>
contract Bank {
  mapping (address => uint) balances;
  
  function deposit() {
    balances[msg.sender] += msg.value;
  }
  
  function withdraw(uint amount) returns (bool) {
    if(amount <= balances[msg.sender]) {
      msg.sender.send(amount);
      balances[msg.sender] -= amount;
      return true;
    }

    return false;
  }
}
          </code></pre>
          <p class="fragment">What is deposited and withdrawn?</p>
          <aside class="notes">
            <p>This is a simple contract that acts as a bank</p>
            <p>All contracts have a persistent data storage that they can use to store arbitrary data. In this case, we declare a mapping from addresses to their balances. Addresses are unique identifiers of users and contracts on Ethereum.</p>
            <p>So if someone wants to make a deposit, we access their address using 'msg.sender', and use it to<br/>increase their balance with the amount that they sent us. I'll explain exactly <i>what it is</i> they sent us soon, just see it as some money-like thing for now. We access it using 'msg.value'.</p>
            <p>And if anyone wants to 'withdraw' an 'amount', we check that they're not trying to overdraw, and then we send that amount to them and return true.</p>
            <p>Remember that in Ethereum, we don't need to trust the executor: We can say that EVERYONE executes this. So this is effectively like a bank that no one controls, even though it's extremely simple.</p>
            <p>We could add rules though. We could require a fee for setting up an account, or loan a fraction of the contract's balance to other users or contracts and so on. You just have to figure out the business logic.</p>
            <strong><i>CLICK</i></strong><br />
            <p>But anyway, I've talked about this money-like thing for a while now, so it's time to explain what it is.</p>
          </aside>
        </section>
        <section class="jack">
          <h2><i>Ether</i> is deposited and withdrawn!</h2>
          <ul>
            <li>Currency/token</li>
            <li class="fragment" data-fragment-index="1">May be sent separately, or with a function call</li>
          </ul>
          <aside class="notes">
            <p>In short, ethereum has an internal token called ether which can be used to transfer real value. Each user and contract on Ethereum has a specific balance of Ether.<br />
            <strong><i>CLICK</i></strong></p>
            <p>Both users and contracts can send any ether they own to any other contract or user.
            </p>
          
          <p>Ether can also be included when calling a contract function, so contracts can behave differently depending on how much ether that was included, as we just saw.</p>
          <p>By the way, has anyone here heard of Bitcoin but not of Ethereum? (Ether is to Ethereum what the currency bitcoin is to the Bitcoin network.)</p>
          </aside>
        </section>
 
        <section class="jack">
          <section data-transition="slide-in fade-out">
          <h2>Case study:<br><span style="font-size:70%">Rock-paper-scissors</span></h2>
<p>A game of two players. Joining costs 10 ether.</p>
          <pre class="fragment"><code data-trim contenteditable>
joinGame : Int -> EthereumEff (success : Bool)
joinGame move = do
  pc <- read playerCount
  if pc < 2 && !value >= 10
    then do
      write players pc (!sender,move)
      write playerCount (pc+1)

      return True
    else

      return False
          </code></pre>
          <p class="fragment"><span style="color:red">Error: </span> Ether is not handled correctly!</p>
          <aside class="notes">
            <p>Ok, so now that we have explained the area that we're working <i>in</i>, it's time to explain what <i>we've</i> been trying to do.</p>
            <p>To do this, we will start with showing you a <i>slightly</i> more complicated contract. It's a game. You might know it, it's called rock-paper-scissors. Basically, two players send their moves and 10 ether each to a contract, which plays the game for them, and pays the winner 20 ether.</p>
            <p>Just a question beforehand: is anyone here not familiar with functional programming?<br/>
              (Ok, no worries, there shouldn't be too many strange things going on, but I'll make sure to explain the code properly anyway. You don't have to worry about the small details)<br />
            <strong><i>CLICK</i></strong><br />
            <p>Ok, so this is the function that players call to join the game. For simplicity, we represent the moves as integers, so the function takes an integer and returns true if the player could join the game and false otherwise.</p>
            <p>As you can see though, the return type is not a <i>normal</i> boolean, but it is something called "EthereumEff" which <i>"contains"</i> a boolean.<br/>
            "EthereumEff" stands for "ethereum effects" and basically, this says that the function might use the state of the Ethereum system in some way.</p>
            <p>In this case for example, it has to check how many players are already in the game. To do this, it has to <i>read</i> a value from the <i>data store</i>, which is why the return type has to be an EthereumEff. The value that is read is saved in 'pc'.</p>
            <p>Then we use 'pc' to check that the game is not full. We <i>also</i> have to check that the player sent enough ether. The amount of ether that was included in the call is accessed using the variable 'value', as we can see here.<br/>
            Just like this 'joinGame' function doesn't return a simple boolean, 'value' doesn't return a simple integer. The exclamation mark basically allows us to treat it as if it was a simple integer.</p>
            <p>So if the game is not full <i>and</i> the player payed enough ether, we should just save the player and its move, increase the number of players and then return true. Otherwise we just return false.</p>
            <p>This might <i>seem</i> reasonable, but there are actually a few errors here.</p>
            <p>For example, what happens if the game was already full? Then we return false, but we don't return the fee for joining the game!<strong><i>CLICK</i></strong></p>
            <p>The player would lose the ether and not be able to retrieve it. So let's fix this! <strong><i>CLICK</i></strong></p>
          </aside>
          </section>
          <section class="jack" data-transition="fade-in fade-out">
          <h2>Case study:<br><span style="font-size:70%">Rock-paper-scissors</span></h2>
          <p>Amended version</p>     
          <pre><code data-trim contenteditable>
joinGame : Int -> EthereumEff (success : Bool)
joinGame move = do
  pc <- read playerCount
  if pc < 2 && !value >= 10
    then do
      write players pc (!sender,move)
      write playerCount (pc+1)
      send (!value-10) !sender
      return True
    else do
      send !value !sender
      return False
          </code></pre>
          <p class="fragment"><span style="color:red">Error: </span> The move is revealed!</p>
          <aside class="notes">
            <p>Ok, so now we return the fee.</p>
            <p>And <i>also</i>, if the player <i>was</i> able to join the game, we return any excess ether.</p>
            <p>As you can see, the solution was really easy, but detecting errors like these can be <i>hard</i>, especially in more complex contracts.</p>
            <p>Anyway, this implementation is better, but one error remains. As you might recall from when Robert explained Ethereum, the state of the system is completely public.<br />
            <strong><i>CLICK</i></strong><br />
            <p>So the <i>second</i> player will be able to see the <i>first</i> player's move <i>before</i> joining the game.</p>
            <p>The solution to this is to use something called cryptographic commitments. We won't show those right now, but keep this example in mind for later.<br />
            <strong><i>CLICK</i></strong><br />
          </aside>
          </section>
        </section>

        <section class="jack">
          <h2>Common errors</h2>
          <table>
            <thead>
              <tr>
                <th>Mistake</th>
                <th class="fragment" data-fragment-index="1">Solution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Wrong handling of ether</td>
                <td class="fragment" data-fragment-index="1">Encode ether flow in the type system</td>
              </tr>
              <tr>
                <td>Openly communicating secret information</td>
                <td class="fragment" data-fragment-index="1">Include crypto schemes in library and compiler</td>
              </tr>
              <!--
              <tr>
                <td>Incentive incompatibility</td>
                <td>?</td>
              </tr> -->
            </tbody>
          </table>
          <aside class="notes">
            <p>Ok, so we have showed you two classes of errors that are common for smart contract developers to make.</p>
            <p>The first was to not handle ether properly, and the second was to upload secret information.</p>
            <p><i>Our thesis</i> is that these problems can be solved at the language level with an extensive type system.</p>
            <p><strong><i>CLICK</i></strong></p>
            <p>To do this, we will use the type system in <i>two</i> ways.<br/>
            The <i>first</i> is to use types to enforce how contracts are allowed to behave.<br/>
            The <i>second</i> is to use types to tell the compiler which values that are secret, and then the compiler can handle the rest for us.<br />
            <strong><i>CLICK</i></strong></p>
          </aside>
        </section>
        <section class="jack">
          <h2>Motivations</h2>
          <ul>
            <li>Catch errors using type system</li>
            <li class="fragment">Functional paradigm</li>
          </ul>
          <aside class="notes">
            <p>And our main motivation for doing this is to catch errors at compile time instead of <i>discovering them</i> at run time. This is what we use the type system for.</p>
            <strong><i>CLICK</i></strong>
            <p>And as you've seen in our examples so far, we also use a functional language.<br/>
            As you may remember, I mentioned in the beginning that there already exist a lot of libraries and stuff that are <i>specialized</i> on describing contracts.<br/>
            It turns out that many of <i>those</i> are functional, so that's why <i>our</i> language is also functional.</p>
            <p>But just to be clear, our goal was <i>not</i> to design a new language or library specialized on contracts.<br/>
            We wanted to do a <i>general-purpose</i> programming language on a <i>smart contract</i> platform. <i>However</i>, our language <i>should</i> make it possible to <i>implement</i> those libraries in an environment where you <i>don't</i> have to trust an executor.</p>
            <p>And now Robert will show what our solutions look like.</p>
            <p><strong><i>CLICK</i></strong>
</p>
          </aside>
        </section>
        <section>
          <section data-transition="slide-in fade-out" data-center="false" class="robert" style="font-size: 0.75em">
            <h2>Catch errors using types</h2>
            <p>
            &nbsp;
            </p>
            <pre><code>
joinGame : Int ->
           EthereumEff (success : Bool)
              
 
 
 
             
            </pre></code>
          <aside class="notes">
            So let's look at an example of how our solution works in practice. We'll modify the type of the joinGame function from rock paper scissors that we saw earlier. We want to keep the same functionality, but include the properties we want to enforce in the type signature. 
          </aside>
          </section>
          <section data-transition="fade-in fade-out" data-center="false" class="robert" style="font-size: 0.75em">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
joinGame : Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = trans
           ; KEEP    = keep
           }
            </pre></code>
            <p>Function is undefined for value < 10</p>
          <aside class="notes">
            <p>The Ethereum effect has some optional parameters. In this example, we include:<br />
            the amount of ether included for this call,<br />
            the ether balance of the contract, <br />
            the amount of outgoing ether transferred to others during the call,<br />
            and the amount of incoming ether that's kept in the contract after the call.</p>
            <p>As Jack mentioned, we want to make sure that the player can only join the game if they pay the fee of 10 ether. As you can see here, we take an additional parameter p. P is a proof that value is at least 10. LTE stands for less-than-or-equal and these curly brackets mean that p is implicit and should be inferred when possible.</p>
            <p>You can also see that we are actually including the VALUE of the parameter value in the type signature, not just its type. In case you're familiar with dependent types, we can do this because our language supports those.</p>
            <p>Now, the type system has made sure that only calls with at least 10 ether will execute this function. Let's see how we can also enforce that the proper amount of ether is kept and transferred.</p>
          </aside>
          </section>
          <section data-transition="fade-in fade-out" data-center="false" class="robert" style="font-size: 0.75em">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
joinGame : Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
            </pre></code>
            <ul>
            <li class="fragment">Transferred and kept ether defined for all paths</li>
            <li class="fragment">First implementation wouldn't type check</li>
            </ul>
          <aside class="notes">
            <p>OK, so if the player joined the game, the contract should keep 10 ether and if they didn't, it should keep nothing. This is defined here. </p>
            <p>We also specify that if the player joined, they should get back any amount of ether exceeding 10 and if they didn't, everything they sent should be returned. You can see that here.<br/>
            <strong><i>CLICK</i></strong><br />
            Again, we are allowed to type check the returned value of the function and even include the result of expressions in the type signature. Keep in mind that this check happens at compile time rather than run time.<br />
            <p><strong><i>CLICK</i></strong></p>
            <p>If we used this type for the first version of the implementation, it wouldn't compile, while the fixed version would.</p>
          </aside>
          </section>
          <section data-transition="fade-in slide-out" class="robert" style="font-size: 0.75em">
            <h2>Catch errors using types</h2>
            <p>
              Hide player move
            </p>
            <pre><code>
joinGame : Commit Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
            </pre></code>
            <ul>
            <li>Commitments part of the language</li>
            <li class="fragment">Revealing function is generated at compile-time:<pre><code>
reveal : Int -> Int -> a -> EthereumEff (success : Bool) {}
</code></pre></li>
            <li class="fragment">Accessed using a library function:<pre><code>
open : Commit a -> EthereumEff (value : Maybe a) {}
            </code></pre></li>
            </ul>
          <aside class="notes">
            <p>Now for the last problem that Jack mentioned; how to hide the player's move from being publicly read. This is done using a cryptographic construction called a commitment - basically, it means that a player can commit to a specific value without that value being known until they choose to reveal it. If we use the type Commit here, we signify to the compiler that it should generate the necessary code for this. <br />
            <strong><i>CLICK</i></strong><br />
            <p>The library supplies two functions - the first takes in the necessary parameters to reveal the value that the player commited to. After this is run, the value can be used in the contract.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The second function, open, returns the commited value if it has been revealed.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Unfortunately, this is not yet part of our implementation, so this last part is not usable in practice yet. But it should not be too hairy to add.</p>
          </aside>
          </section>
        </section>
        <section>
          <h2>Type-correct version</h2>
          <pre><code class="Haskell" style="max-height: 500px;">
joinGame : Commit Int -> {auto p : LTE 10 value} ->
           EthereumEff (success : Bool)
           { VALUE   = value 
           ; BALANCE = balance
           ; TRANS   = (if success then (value-10) else value)
           ; KEEP    = (if success then 10         else 0)
           }
joinGame {value} move = do
  pc <- playerCount
  if pc < 2
    then do write players pc (!sender,move)
            write playerCount (pc+1)
            send (value-10) !sender
            keep 10
            pureM True
    else do send value !sender
            pureM False   
          </pre></code>
          
          <aside class="notes">
            So here is the complete joinGame function. The implementation is exactly the same as we saw before, with one small change. pureM is exactly the same as return, but allows us to have differing output effects depending on the return value. Obviously, we would also need code for resolving the winner and so on, but hopefully this is enough to give you an idea of what's going on.
          </aside>
        </section>
        <section class="robert">
          <h2>Implementation</h2>
          <h3>Language: Idris</h3>
          <ul>
            <li class="fragment">Very similar to Haskell, but...</li>
            <li class="fragment">Dependent types</li>
            <li class="fragment">Algebraic effects for environment interaction</li>
            <li class="fragment">Strictly evaluated</li>
            <li class="fragment">Pluggable backends</li>
          </ul>
          <aside class="notes">
            <p>So, now that you've seen how our solution works, let's get down to how we've implemented it. We chose to use an already existing language called Idris. Has anyone heard of it before?<br />
            <strong><i>CLICK</i></strong><br />
            <p>For those of you who haven't, maybe you think the code we showed looked like Haskell. Idris is heavily inspired by Haskell, and the syntax is very similar. I'll just run through the main reasons why we think that Idris is a better fit for Ethereum than Haskell. This is partly because at the start of the project, we were dead set on going from Haskell.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The big thing is dependent types. This is what allowed us to be so expressive in the type signatures.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Side effects are icky in any purely functional language. Idris models this using something called algebraic effects, and they are part of the core library. This allowed us to express interaction with the environment in a natural way.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Executing code on Ethereum is actually pretty expensive. So we want something with minimal runtime overhead. Haskell uses lazy evaluation, which is pretty expensive. Idris, on the other hand, uses strict evaluation by default, so we didn't have to hack around laziness in our code generator.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Finally, Idris is designed to be easily extended to target new platforms. We looked quite a bit at GHC, the main Haskell compiler, and it is not very well documented how to do this with Haskell. </p>
            <p>So without further ado, let's look at what we've actually done.</p>
          </aside>
        </section>
        <section class="robert">
          <h2>Implementation</h2>
          <h3>Library: Effects</h3>
          <ul>
            <li class="fragment">ETH: Handle ether flow</li>
            <li class="fragment">ENV: Depend on the environment</li>
            <li class="fragment">STORE: Read from and save to data store</li>
          </ul>
          <h3 style="margin-top: 1.5em">Code generator</h3>
          <ul>
            <li class="fragment">Plugs into Idris compiler API</li>
            <li class="fragment">Outputs Serpent</li>
            <li class="fragment">Only works for very simple contracts ATM</li>
            <li class="fragment">Commitments not yet implemented</li>
          </ul>
          <aside class="notes">
            <p>Our implementation consists of two main parts: A library of effects and a code generator. We have made three effects that can be used independently. They supply both the type checking and allow contract functions to use effectful operations in the implementation.
            <br /><strong><i>CLICK</i></strong><br />
            The first effect is the one we used to handle the flow of ether in the joinGame function.<br />
            <strong><i>CLICK</i></strong><br />
            <p>ENV allows us to get things from the environment. Stuff like the addresses of the sender and the contract, or the current time.<br />
            <strong><i>CLICK</i></strong><br />
            <p>STORE allows us to interact with the contract's data store.</p>
            <p>The EthereumEff we saw before is just syntactic sugar which includes all three.</p>
            <p>That about the library. Let's talk about the code generator.<br />
            <strong><i>CLICK</i></strong><br />
            <p>As I said, we use the Idris compiler API as a library to get an intermidiate abstract syntax tree representation of the contract as input.<br />
            <strong><i>CLICK</i></strong><br />
            <p>We actually don't output Ethereum byte code directly, but instead we output Serpent code. Serpent is the Python-like smart contract language. The Serpent compiler can then be used for the final step.<br />
            <strong><i>CLICK</i></strong><br />
            <p>The current version of the code generator is not complete. All the type checking works as intended, but it only generates working code for a subset of contracts. Let's look at how this is used in practice and see if it works.</p>
          </aside>
        </section>

        <section class="robert">
          <h2>Demo time!</h2>
          <aside class="notes">
            <p>I'll use our code generator to compile a simple contract from Idris to Serpent and then run it on a simulated version of the Ethereum system supplied with Serpent. </p>
<p></p>
            <p>$ vim Namecoin.idr</p>
<p></p>
            <p>This is an Idris implementation of  a simple key value store. We have one storage variable, db, which is a mapping from integers to integers. If we look at the register function, you can see that we have specified that only the user with a hardcoded address is allowed to register values in the registry. This means that it will be a type error if anyone else tries to register a value. The get function is free for anyone to use. Let's try to compile and run it.</p>

<p></p>
            <p>$ make namecoin_eio</p>
            <p>$ vim Namecoin.se</p>
<p></p>
            <p>Here is the output from our code generator. This is Serpent. This will be fed to a Python script that does the final stage of the compilation and runs a simulator to debug it.</p>
            <p>Let's take a lok at that.</p>
<p></p>
            <p>$ vim runner.py</p>
<p></p>
            <p>The details here are not too important.</p>
            <p>We read in the serpent source.</p>
            <p>Set up the environment.</p>
            <p>We try get and print a value with the key 1337, which has not been set yet.</p>
            <p>We set the value to 42.</p>
            <p>And try to read it again.</p>
<p></p>
            <p>$ ./runner.py</p>
<p></p>
            <p>Looks like it works. Let's see what happens if the sender check fails by changing the owner address.</p>
<p></p>
            <p>* Change owner address</p>
            <p>$ make namecoin_eio</p>
            <p>$ ./runner.py</p>
<p></p>
            <p>Now it doesn't work anymore.</p>
<p></p>
            <p>So how is this actually enforced? Of course the runtime needs some way to know how to pass the proper arguments to "register" and when it can't and should fail.</p>
<p></p>
            <p>We do this using something we call wrapper functions. They should be possible to automatically generate, but right now you'd have to write them yourself. Let's have a look.</p>
<p></p>
            <p>$ vim Namecoin_EIO</p>
<p></p>
            <p>It's kind of verbose and we'll just glance through this. Let's look at "get". Since there are no types to enforce, this is just boiler plate with the raw values for all effect parameters.  If we look at "register" on the other hand, we see that we have to check if the sender is indeed the owner before passing it on to the actual function. You can see that here. If it fails, nothing should happen. In this context, "nothing" includes returning all included ether to the sender. This is also where we would pass in any proofs required by the type. Like the one from Rock Paper Scissors where the ether value had to be at least 10.</p>
<p></p>
            <p>Here you see a list of which functions should be accessible from the outside. </p>
          </aside>
        </section>
        <section>
          <h2>Summary</h2>
        <p>An expressive type-system can...
          <ul>
            <li>Catch large classes of errors at compile-time</li>
            <li class="fragment">Generate boiler-plate code</li>
          </ul>
        </p>
        <aside class="notes">
          <p>Let's wrap things up. In summary, we have showed how we can use algebraic effects in combination with dependent types to specify in detail how a smart contract is intended to work and catch errors at compile time.<br />
            <strong><i>CLICK</i></strong><br />
            <p>Knowing so much about a programs intended behaviour at compile time also allows us to generate a significant amount of boilerplate code.</p>
        </aside>
        </section>
        <section>
        <h2>Work in progress</h2>
         <ul>
          <li>Proof-of-concept implementation</li>
          <li>Lots of future work</li>
         </ul>
          
        <aside class="notes">
          So, we have laid down the theory and design for an implementation of this applying Idris to Ethereum. The implementation itself is still just a proof of concept and especially the code generator will probably have to be rewritten from scratch before it's ready for production use. We hope that someone will pick ball and build upon our work.
        </aside>
        </section>
        <section style="">
          <h1>THANK YOU</h1>
          <h2>Questions?</h2>
              <footer><a href="https://github.com/vindaloo-thesis" target="_blank">https://github.com/vindaloo-thesis</a></footer>
            </ul>
          
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: false,
        progress: true,
        history: true,
        center: false,
        touch: true,
        overview: true,
        mouseWheel: true,
        hideAddressbar: true,


        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src : 'lib/js/jquery-2.2.0.min.js', async: true},
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });
var changeTitle = function(title) {
  console.log($('.progress span'));
  $('.progress span').html(title);
};

Reveal.addEventListener( 'slidechanged', function( event ) {
  console.log(event.indexh);
  if(event.indexh <= 1) {
      changeTitle('')
  } else if(event.indexh <= 10) {
      changeTitle('1.&nbsp;Background')
  } else if(event.indexh <= 13) {
      changeTitle('2. Solution')
  } else if(event.indexh <= 15) {
      changeTitle('3. Implementation')
  } else if(event.indexh <= 16) {
      changeTitle('4. Demonstration')
  } else if(event.indexh <= 18) {
      changeTitle('5. Summary')
  } else {
    changeTitle('6. Questions')
  }
    // event.previousSlide, event.currentSlide, event.indexh, event.indexv
} );
window.addEventListener("mousedown", handleClick, false);
//window.addEventListener("contextmenu", function(e) { e.preventDefault(); }, false);

function handleClick(e) {
  e.preventDefault();
  if(e.button === 0) Reveal.next(); 
  //if(e.button === 2) Reveal.prev(); 
}
    </script>

  </body>
</html>

