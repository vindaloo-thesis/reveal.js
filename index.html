<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Type-driven contract development</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <style type="text/css">
    code {
      color: #a8c;
    }
    </style>

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section style="text-align: left;">
          <h3>Safer smart contracts through type-driven development</h3>
          <p>
          <div style="line-height:70%;">
          <small>Jack Pettersson and Robert Edström</small><br>
            <small>MSc thesis at Chalmers University of Technology</small>
          </div>
          </p>
          
        </section>

        <section>
          <h2>Contracts</h2>
          <ul>
            <li>Conditional agreements</li>
            <li>Essentially formal</li>
            <li>Possible to automate?</li>
          </ul>
          <aside class="notes">
          <p>Ok, so contracts are very central to our current society. But what are they?
          They are essentially written agreements.</p>
          <p>For example, "if you don't pay your rent, I have the right to kick you our of your apartment"</p>
          <p>Of course most contracts are much more complicated than that, but at their core, they are more or less logical formulas:<br/>
          "if x happens, y holds" or "at time x, perform y"</p>
          <p>As we know, computers are very good at logic, so the question is:<br/>
          can we describe contracts using code and execute them?</p>
          <p>The answer is: Yes, we can!</p>
          <p>This has been known by computer scientists for a long time, and there exist many formal languages and libraries for specifying, executing and analyzing contracts.</p>
          <p>A vending machine can be seen as a primitive smart contract:<br />
            "If you deposit a coin, you will receive a soda"</p>
          </aside>
        </section>

        <section data-transition="slide-in fade-out">
          <h2>Example contract:<br>European option</h2>
          <p>"At time <code>t</code>, party <code>a</code> may buy asset <code>x</code> from party <code>b</code> for price <code>y</code>"</p>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
function buy() {
  if(currentTime == t) {
    a.give(b,y)
    b.give(a,x)
  }
}
          </code></pre>
          <p class="fragment">Who executes this?</p>
          <aside class="notes">
          <p>Just to give you an intuition, let's take a very common financial contract and try to encode it as a program.</p>
          <p>We'll take a so-called European Option. They allow the holder to buy an asset at a fixed price, but only at a particular time.</p>
          <p>Here is some object-oriented pseudocode that encodes these rules. If the holder wants to buy the asset, they simply call the buy function. The function checks the current time and transfers the asset and the money.</p>
          <p>This is all very well, but there is one major question:<br/>
          Who executes this code? On whose computer is it running? Can we trust that person?</p>
          <p>If we should start to codify contracts, it is extremely important that they can't be modified by anyone and that anyone can verify that they are executed correctly.</p>
          <p>The perfect scenario would be if the code could "execute itself", without any possibility of interference.</p>
          </aside>
        </section>
        
        <section>
          <h2>Smart contracts</h2>
          <ul>
            <li>Self-enforcing contracts</li>
            <li>Primitive example: vending machines</li>
            <li class="fragment">Now: smart contract platforms</li>
            <li class="fragment">Applications: finance, IoT, commerce, computer protocols, gambling, ...</li>
          </ul>
          <aside class="notes">
          <p>That's what smart contracts are about!</p>
          <p>The last few years, programmable smart contract platforms have become a thing. They offer developers a programming language to specify arbitrary smart contracts, and then the platforms ensures that they are executed exactly as specified.</p>
          <p>Except the obvious financial applications, this can be used in lots of fields.</p>
          <p>Just as an example, IBM has experimented with using a smart contract platform as the backbone for the internet of things, which seems very promising. This would allow connected devices to negotiate and decide on their behavior collectively, without relying on any servers.</p>
          </aside>
        </section>
        
        
        
        <section>
          <h2>Ethereum</h2>
          <h3>A smart contract platform</h3>
          <ul>
            <li>Peer-to-peer network executing...</li>
            <li><strong>Arbitrary</strong> rules, leading to a...</li>
            <li><strong>Globally</strong> accepted state</li>
          </ul>
          <p class="fragment">Result: the rules enforce themselves</p>
          <aside class="notes">
          <p>Ok, so we have looked at the smart contract platform Ethereum.</p>
          <p>It is a peer-to-peer network. Who here is familiar with P2P networks?</p>
          <p>(Ok, are you familiar with Bittorrent or Bitcoin? Ok, so both of those are P2P netowrks. It essentially means that all computers in the network are equal in terms of network control. There is no central server or anything else that coordinates the network, but all participants communicate directly with each other. Effectively, no particular computer is required for the network to operate. It is just enough that there are <i>some</i> computers in the network.)</p>
          <p>Ok, so the participants in this P2P network execute arbitrary rules. These rules are the contracts on the platform and can be specified by anyone.</p>
          <p>After executing the contract, the participants verify that they all got the same result. This result is published for the world to see.</p>
          <p>This means that a network which no one controls is able to say "<strong>this</strong> is the result of executing these contracts", and if anyone disagrees, it is easy to prove them wrong</p>
          <p>In summary, the contracts essentially execute themselves, without any need to trust the executor.</p>
          </aside>
        </section>
<!--
        <section>
          <h2>Ethereum</h2>
          <h3>Globally accepted state</h3>
          <ul>
            <li>Reached through consensus algorithm</li>
            <li class="fragment">Blockchain - generalization of the Bitcoin ledger</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
      -->
        <section>
          <h3>Ethereum smart contract languages</h3>
          <p>Contracts = byte code on the Ethereum Virtual Machine</p>
          <ul>
            <li class="fragment">Solidity ≈ JavaScript</li>
            <li class="fragment">Serpent ≈ Python</li>
            <li class="fragment">LLL ≈ LISP</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
        <section data-transition="slide-in fade-out">
          <h2>Example contract</h2>
          <h3>Name registry</h3>
          <p>Written in Solidity</p>
          <pre class="fragment"><code class="hljs" data-trim contenteditable>
contract NameRegistry {
  mapping (string => string) names;
  
  function register(string name, string value) returns boolean {
    if(names[name] == 0) {
      names[name] = value;
      return true;
    }
    return false;
  }
  
  function lookup(string name) returns string {
    return names[name];
  }
}
          </code></pre>
          <p class="fragment">Everyone executes this!</p>
          <aside class="notes">
          </aside>
        </section>
        <section>
          <h2>Ether</h2>
          <ul>
            <li>Currency/token</li>
            <li class="fragment">May be sent separately</li>
            <li class="fragment">May be sent as part of function call</li>
          </ul>
          <aside class="notes">
          </aside>
        </section>
 
        <section>
          <h2>Motivations</h2>
          <ul>
            <li>Catch bugs at compile time</li>
            <li>What can be enforced using the type system?</li>
            <li class="fragment">Annotate types to generate boilerplate code</li>
            <li class="fragment">Functional paradigm</li>
          </ul>
          
        </section>
        <section>
          <section data-transition="slide-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
<p>A game of two players. Joining costs exactly 10 ether.</p>
          <pre class="fragment"><code data-trim contenteditable>

playerMove : Int -> EthereumEff (success : Bool)
playerMove move = do
  pc <- read playerCount
  if pc < 2
    then do
      write players pc !sender
      write moves pc move
      write playerCount (pc+1)

      pureM True
    else do

      pureM False
          </code></pre>
          <p class="fragment">Ether is not handled correctly!</p>
          
          </section>
          <section data-transition="fade-in fade-out">
          <h2>Case study:<br>Rock-paper-scissors</h2>
          <p>Amended version</p>
          <pre><code data-trim contenteditable>
playerMove : Int -> EthereumEff (success : Bool)
playerMove move = do
  pc <- read playerCount
  if pc < 2
    then do
      write players pc !sender
      write moves pc move
      write playerCount (pc+1)
      send (v-10) !sender
      pureM True
    else do
      send v !sender
      pureM False
          </code></pre>
                    <p class="fragment">Better, but the move is still revealed!</p>
          
</section>
        </section>

        <section>
          <h2>Common errors</h2>
          <table>
            <thead>
              <tr>
                <th>Mistake</th>
                <th>Solution</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>No handling of ether</td>
                <td>Encode ether flow in the type system</td>
              </tr>
              <tr>
                <td>Openly communicating secret information</td>
                <td>Include crypto schemes in library and compiler</td>
              </tr>
              <!--
              <tr>
                <td>Incentive incompatibility</td>
                <td>?</td>
              </tr> -->
            </tbody>
          </table>

          
        </section>
        <section>
          <h2>Implementation</h2>
          <h3>Language: Idris</h3>
          <ul>
            <li class="fragment">Very similar to Haskell, but...</li>
            <li class="fragment">Dependent types</li>
            <li class="fragment">Algebraic effects for environment interaction</li>
            <li class="fragment">Strictly evaluated</li>
          </ul>

          

        </section>
        <section>
          <section data-transition="slide-in fade-out" data-center="false">
            <h2>Catch errors using types</h2>
            <p>
            &nbsp;
            </p>
            <pre><code>
playerMove : Int ->
             EthereumEff (success : Bool)
              
 
 
 
             
            </pre></code>
          </section>
          <section data-transition="fade-in fade-out" data-center="false">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
playerMove : Int -> {auto p : LTE 10 value} ->
             EthereumEff (success : Bool)
             { VALUE   = value 
             ; BALANCE = balance
             ; TRANS   = trans
             ; KEEP    = keep
             }
            </pre></code>
            <ul>
            <li>Function is undefined for value < 10</li>
            </ul>
          </section>
          <section data-transition="fade-in fade-out" data-center="false">
            <h2>Catch errors using types</h2>
            <p>
              We start by including ether in the type signature:
            </p>
            <pre><code>
playerMove : Int -> {auto p : LTE 10 value} ->
             EthereumEff (success : Bool)
             { VALUE   = value 
             ; BALANCE = balance
             ; TRANS   = (if success then (value-10) else value)
             ; KEEP    = (if success then 10         else 0)
             }
            </pre></code>
            <ul>
            <li>Transferred and kept ether defined for all paths</li>
            <li class="fragment">Previous implementation wouldn't type check</li>
            </ul>
          </section>
          <section data-transition="fade-in slide-out">
            <h2>Catch errors using types</h2>
            <p>
              Hide player move
            </p>
            <pre><code>
playerMove : Commit Int -> {auto p : LTE 10 value} ->
             EthereumEff (success : Bool)
             { VALUE   = value 
             ; BALANCE = balance
             ; TRANS   = (if success then (value-10) else value)
             ; KEEP    = (if success then 10         else 0)
             }
            </pre></code>
            <ul>
            <li>Commitments part of the language</li>
            <li class="fragment">Revealing function is generated at compile-time</li>
            <li class="fragment">Accessed using a library function:<pre><code>
open : Commit a -> a
            </code></pre></li>
            <li class="fragment">Not implemented</li>
            </ul>
            
          </section>
        </section>
        <section>
          <h2>Type-correct implementation</h2>
          <pre><code class="Haskell" style="max-height: 500px;">
playerMove : Commit Int -> {auto p : LTE 10 value} ->
             EthereumEff (success : Bool)
             { VALUE   = value 
             ; BALANCE = balance
             ; TRANS   = (if success then (value-10) else value)
             ; KEEP    = (if success then 10         else 0)
             }
playerMove {value} move = do
  pc <- playerCount
  if pc < 2
    then do write players pc !sender
            write moves pc move
            write playerCount (pc+1)
            keep 10
            send (value-10) !sender
            pureM True
    else do send value !sender
            pureM False   
          </pre></code>
          
        </section>
        <section>
          <h2>Implementation</h2>
          <h3>Library: Effects</h3>
          <ul>
            <li class="fragment">ETH: Handle ether flow</li>
            <li class="fragment">ENV: Depend on the environment</li>
            <li class="fragment">STORE: Read to and save from data store</li>
          </ul>
          <h3 style="margin-top: 1.5em">Code generator</h3>
          <ul>
            <li class="fragment">Plugs into Idris compiler API</li>
            <li class="fragment">Outputs Serpent</li>
            <li class="fragment">Only works for very simple contracts ATM</li>
          </ul>
        </section>

        <section>
          <h2>Demo time!</h2>
          <aside class="notes">
            We'll now show you how our impkementation can be used. We'll use our code generator to compile a simple contract from Idris to Serpent and then run it on a simulated version of the Ethereum system supplied with Serpent. 

            $ vim Namecoin.idr

            This is just a simple key value store.  We have one storage variable, db, to map integers to integers. As you can see, the "get" function uses the Store effect and returns the value stored for the given key.

            If we look at the "register" function, we can see that we also use the Environment effect. It takes three parameters, and the first two here are implicit and can be anything. But for the third one, representing the address of the user who initiated the call, we have supplied a fixed value. This means that it will be considered a type error if anyone else tries to register a value. Let's try to compile and run it.

            $ make namecoin_eio
            $ vim Namecoin.se

            Here is the output from our code generator. This is Serpent, one of the existing contract languages for Ethereum that we mentioned before. This will be fed to a Python script that does the final stage of compilation and runs a simulator to debug it.

            $ vim runner.py

            The details here are not too important.
            We read in the serpent source.
            Set up the environment.
            We try get and print a value with the key 1337, which has not been set yet.
            We set the value
            And try to read it again.

            $ ./runner.py

            It works as intended. Let's try to see what happens if the origin check would fail by changing the owner address.

            * Change owner address
            $ make namecoin_eio
            $ ./runner.py

            Now it doesn't work anymore, since the origin check fails. 

            So how is this actually enforced? Of course the runtime needs some way to know how to pass the proper arguments to "register" and when it can't and should fail.

            We do this using something we call wrapper functions. This is something that should be possible to automatically generate, but in our current implementation the developer has to write these themselves. Let's have a look.

            $ vim Namecoin_EIO

            It's kind of verbose and we'll just glance through this. Let's look at "get". Since there are no types to enforce, we can just pass on the value. If we look at "register", you can see that we have to check if the origin is indeed the owner before passing it on to the actual function. This is also where we would pass in any proofs required by the type. Like the one from Rock Paper Scissors where the value had to be at least 10.




          </aside>
        </section>
        <section>
          <h2>Summary</h2>
<p>An expressive type-system can...
          <ul>
            <li>Catch large classes of errors at compile-time</li>
            <li class="fragment">Generate boiler-plate code</li>
          </ul>
</p>
          
        </section>
        <section>
        <h2>Work in progress</h2>
         <ul>
          <li>Proof-of-concept implementation</li>
          <li>Lots of future work</li>
         </ul>
          

        </section>

        <section style="text-align: left;">
          <h1>THANK YOU</h1>
            <p> - <a href="https://github.com/vindaloo-thesis/examples">https://github.com/vindaloo-thesis/idris-se</a> </p>
            <p>- Questions? Feedback? Ideas? Talk to us! :)</p>
            <p>- <a href="mailto:jack.pettersson@consensys.net">jack.pettersson@consensys.net</a>, <a href="mailto:robert@cacti.se">robert@cacti.se</a></p>
          </p>
          
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: false,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true },
          { src: 'plugin/notes/notes.js', async: true }
        ]
      });

    </script>

  </body>
</html>

